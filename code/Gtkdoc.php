<?php

class Gtkdoc extends Page {

    static $icon = 'gtkdoc/images/gtkdoc';
    static $description = 'Incorporates into the pages tree an ebook generated by gtk-doc';
    static $allowed_children = array();
    static $db = array(
        'DevhelpFile' => 'Text',
    );
    static $casting = array(
        'GtkdocLink' => 'Text',
    );


    private $node = null;


    private function _getAbsoluteLink($node) {
        $path = dirname($this->DevhelpFile);
        return $path . DIRECTORY_SEPARATOR . $node['link'];
    }

    private function &_getTOC() {
        static $cache = array();
        $file = $this->DevhelpFile;

        if (! array_key_exists($file, $cache)) {
            $doc = new DOMDocument();
            @$doc->loadHTMLFile($file);

            $toc = array(
                '' => array(
                    'ID'   => $this->ID,
                    'name' => $this->Title,
                    'link' => ''
            ));
            foreach ($doc->getElementsByTagName('sub') as $sub) {
                $link = $sub->getAttribute('link');
                $name = $sub->getAttribute('name');
                $parent = &$toc[$sub->parentNode->getAttribute('link')];
                $toc[$link] = array(
                    'name'   => $name,
                    'link'   => $link,
                    'parent' => &$parent
                );
                $parent['sub'][] = &$toc[$link];
            }

            // Cache the TOC tree into $cache
            $cache[$file] = &$toc;
        }

        return $cache[$file];
    }

    private function is_path($href) {
        // Dumb algorithm: $href is a path if starts with /
        return $href[0] == '/';
    }

    private function _resolveHRef(DOMAttr $attr) {
        $href = $attr->value;

        if (self::is_path($href)) {
            // Try to forcefully resolve local references to gnome.org
            if (preg_match('|/([^/]*)/([^/]*)$|', $href, $matches)) {
                $module = $matches[1];
                $page = $matches[2];
                $href = "http://developer.gnome.org/$module/stable/$page";
            }
        } elseif (Director::is_relative_url($href)) {
            // Prepend URLSegment on relative URLs
            $href = Controller::join_links($this->URLSegment, $href);
        }

        $attr->value = $href;
    }

    private function _getContentFromDOM(DOMDocument $doc) {
        $xpath = new DOMXPath($doc);
        $result = $doc->createElement('div');
        $result->setAttribute('class', 'gtkdoc');

        // Set the metadescription of this page, if found
        $element = $xpath->query('//div[@class="refnamediv"]//h2/../p|//h3')->item(0);
        $element and $this->setField('MetaDescription', trim($element->nodeValue));

        // Import valid elements into $result
        foreach ($xpath->query('body/div[@class="book" or @class="part" or @class="chapter" or @class="refentry" or @class="index" or @class="glossary"]') as $element) {
            $result->appendChild($element);
        }

        // No valid elements are found: fallback to the whole content of body
        if (! $result->hasChildNodes()) {
            foreach ($xpath->query('body/*') as $element)
                $result->appendChild($element);
        }

        // Remove invalid elements from the result: the helper
        // $elements array is used to avoid modifying the DOM
        // while iterating over it
        $elements = array();
        foreach ($xpath->query('(.//div[@class="titlepage"])[1]|.//div[@class="refnamediv"]', $result) as $element) {
            $elements[] = $element;
        }
        foreach ($elements as $element) {
            $element->parentNode->removeChild($element);
        }

        // Resolve href targets
        foreach ($xpath->query('.//a/@href', $result) as $element) {
            $this->_resolveHRef($element);
        }

        return $doc->saveHTML($result);
    }


    /**
     * Adds an entry for the devhelp file.
     *
     * @return FieldList The new list of fields for the CMS.
     */
    public function getCMSFields() {
        $fields = parent::getCMSFields();

        $field = new TextField('DevhelpFile', _t('GtkDoc.DEVHELP_FILE', 'Path to the .devhelp2 file'));
        $fields->addFieldToTab('Root.Main', $field, 'Content');

        return $fields;
    }

    /**
     * Returns a raw representation of the TOC.
     *
     * The string returned is captured from print_r(). It is
     * intended to be used for debugging purpose.
     *
     * @returns  A string representation of the TOC.
     */
    public function TOC() {
        $toc = $this->_getTOC();
        return print_r($toc[''], true);
    }

    /**
     * Look up a node by link.
     *
     * The @link string is expected to be a (usually HTML) file bound
     * to an existent node, such as "GtkWidget.html".
     *
     * @param $link  The file bound to the node to find.
     * @returns      The requested node, or null if @link does not exist.
     */
    public function &lookupNode($link) {
        $toc = $this->_getTOC();
        $node = &$toc[$link];

        // Node not found: check if it is the root node
        if (! isset($node) && $link == $this->URLSegment) {
            $node = &$toc[''];
        }

        return $node;
    }

    /**
     * Creates a new page from a node or link or
     * return the previously created one.
     *
     * @param Array|String $source The node or link identifying
     *                             the GtkDoc page to create.
     * @return GtkDoc              A new page.
     */
    public function getSectionPage($source) {
        $link = is_array($source) ? $source['link'] : (string) $source;
        $node = &$this->lookupNode($link);
        if (! isset($node)) {
            return null;
        }

        if (! isset($node['page'])) {
            $page = $this->duplicate(false);
            $page->setField('ID', $link);
            $page->setField('Title', $node['name']);
            $page->setField('GtkdocLink', $link);
            $page->node = &$node;
            $node['page'] = $page;
        }

        return $node['page'];
    }

    /**
     * Overrides the RelativeLink() to append GtkdocLink to the URL.
     *
     * @param string $action  Additional text to append to the URL.
     * @return string         The relative link to this page.
     */
    public function RelativeLink($action = null) {
        return parent::RelativeLink(Controller::join_links($this->GtkdocLink, $action));
    }

    /**
     * Returns the node of this page. The returned node
     * is a reference to the original one, not a copy.
     *
     * @return Array The node bound to this page.
     */
    public function &getNode() {
        isset($this->node) or $this->node = &$this->lookupNode($this->GtkdocLink);
        return $this->node;
    }

    /**
     * Returns the parent node of this page. The returned
     * node is a reference to the original one, not a copy.
     *
     * @return Array The parent node of this page or null
     *               if this is the root node.
     */
    public function &getParentNode() {
        $node = &$this->getNode();
        return $node['parent'];
    }

    /**
     * Overrides SiteTree::parent() to return the parent Gtkdoc model
     * without accessing the database.
     *
     * @return SiteTree Parent of this page.
     */
    public function getParent() {
        $parent_node = &$this->getParentNode();

        if (isset($parent_node['ID'])) {
            $id = $parent_node['ID'];
            return DataObject::get_one('SiteTree', '"SiteTree"."ID" = ' . $id);
        }

        return isset($parent_node) ? $this->getSectionPage($parent_node) : parent::getParent();
    }

    /**
     * Overrides Hierarchy::Children() implementation to return the children
     * of the current page without accessing the database.
     *
     * @return ArrayList List of child pages or null on no children.
     */
    public function Children() {
        $node = &$this->getNode();
        if (! isset($node['sub'])) {
            return null;
        }

        $children = new ArrayList();
        foreach ($this->node['sub'] as $subnode) {
            $child = $this->getSectionPage($subnode);
            $children->push($child);
        }

        return $children;
    }

    /**
     * Dynamically returns a valid <div> with the content (in HTML)
     * picked up from a GtkDoc html file.
     *
     * @return string  Raw HTML text.
     */
    public function getContent() {
        if (! $this->getParent()) {
            // This is the root node: return the content set in the CMS
            return $this->getField('Content');
        }

        $file = $this->_getAbsoluteLink($this->getNode());
        $data = file_get_contents($file);

        // Strip GTKDOCLINK tags: much easier to do with regex
        // than using DOM APIs.
        $data = preg_replace('/<?GTKDOCLINK.*?>/', '', $data);

        $doc = new DOMDocument();
        $doc->strictErrorChecking = false;
        @$doc->loadHTML($data);
        return $this->_getContentFromDOM($doc);
    }
}

class Gtkdoc_Controller extends Page_Controller {

    /**
     * A Gtkdoc page is identified by its link, that is the file name
     * of the HTML file generated by gtk-doc. This link is stored in
     * the "GtkdocLink" field.
     *
     * @param SS_HTTPRequest $request  The object that is responsible for
     *                                 distributing request parsing.
     * @param DataModel $model         The data model (???).
     * @return SS_HTTPResponse         The response that this controller
     *                                 produces, including HTTP headers
     *                                 such as redirection info.
     */
    public function handleRequest(SS_HTTPRequest $request, DataModel $model = null) {
        if ($request->match('$Page!')) {
            $request->shiftAllParams();
            $request->shift();
        } else {
            // With the base URL, forward the request
            // to the default handleRequest()
            return parent::handleRequest($request, $model);
        }

        // Check for page existence
        $ext = $request->getExtension();
        $ext and $ext = '.' . $ext;
        $link = $request->latestParam('Page') . $ext;
        $page = $this->getSectionPage($link);
        if (! isset($page)) {
            return $this->httpError(404, 'Page not found');
        }

        // Forward the request to a new controller
        // that uses $page as model.
        $controller = Gtkdoc_Controller::create($page);
        return $controller->handleRequest($request, $model);
    }
}
